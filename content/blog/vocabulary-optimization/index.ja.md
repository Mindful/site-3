+++
slug = "/blog/vocabulary-optimization"
date = "2025-01-23"
title = "最適な複合語語彙を見つける手法"
+++

日本語を学んでいく中で特に印象的だったのは、覚えた漢字が一定数を超えると、それまで見たことのない単語でも読めたり意味を推測できたりすることです。これは漢字そのものが意味を持つから可能です。たとえば、建物は建つ物、自信は自分を信じること、などのように漢字から意味がわかる単語が少なからずあります。初めて耳にする言葉でも、その漢字を推測して意味に辿り着けることもあります。

英語でも見たことのない単語の意味を推測できる場合はありますが、主に`-ness`（例：kindness）や`re-`（例：rewrite）といった生産的な接辞か、認識しやすいラテン語由来の語根を持つ単語です。英語において、漢字から推測可能な単語に最も近いのは複合語だと思っています。すべてが推測可能というわけではありませんが、`mailbox`（郵便箱）、`firefighter`（消防士）、`waterfall`（滝）など、わかりやすいものもあります。この話がなぜ大事なのかというと、こういった推測しやすい複合語が多いほど新しい語彙を覚える負担が減ります。たとえば、[エスペラント](https://en.wikipedia.org/wiki/Esperanto)（最も広く使われている人工言語）は、生産的な接辞と複合語を広範に活用しています（今回話すのは複合語のみですが）。

さて、本題は複合語を自動生成する方法があるかどうかですね。複合語を構成する単語がその複合語の意味と関連している必要があります。同時に、語彙全体も考える必要があります。1つの単語が多くの複合語に使われすぎると、手がかりとしての役割が薄れます。そのため、複数の基準を考慮しながら、最適な複合語語彙を見つける方法が必要になります。

## 探索問題としての捉え方

まず初めに、表現したい意味の集合を考えます。これを「アイデア」と呼び、英単語で表現します。このアイデアの集合 を*I*とし、 語彙を構築するプロセスは、*I* から基礎語の集合 *B* を選び（*B ⊂ I*）、*I* の残りの要素を *B* の2つの単語を組み合わせた複合語として表現することと考えられます[^vo_1]。これにより、複合語の集合 *C* が生まれます。*C* の各要素は、アイデアと2つの基礎語を表すタプルになります：*C = { (i, b1, b2) ∣ b1 ∈ B, b2 ∈ B, i ∈ I }*。

たとえば、以下のような3つの単語が *I* に含まれているとします：

> sky

> water

> rain

この場合、最適な結果は `sky` と `water` を基礎語に選び、`rain` を `skywater` という複合語で表現することだと言えるでしょう。つまり、基礎語の集合は以下のようになります：

> *B* = {sky, water}

そして、それらが組み合わさって以下の複合語の集合が得られます：

> *C* = {(rain, sky, water)}

しかし、実際の言語では *I* が何千、何万といった規模になるため[^vo_2]、これを手作業で行うのは現実的ではありません。

--- working
ただし、*I* を与えられたとし、*B* と *C* を生み出すプロセスを、次々に選択を行う長い決定の連続とみなすことができます。この決定空間は非常に広大ですが、自動探索することが可能です。必要なのは、解を評価するための基準です。

たとえば、スコアリング関数 *S(I, B, C)* を以下のように設定できます：
1. *C* に含まれる各複合語の質を最大化する
2. 多数の複合語に使用される基礎語の数を最小化する
3. #2を損なわない範囲で可能な限り多くの複合語を作る[^vo_3]

## 私の試み（モンテカルロ木探索）

[モンテカルロ木探索](https://en.wikipedia.org/wiki/Monte_Carlo_tree_search)（MCTS）アルゴリズムは、ゲームAIでよく知られていますが、一連の決定としてモデル化できるものであれば、任意の問題に適用できます。この問題にも自然に適合すると思いましたが、最適化手法に詳しいわけではありません。[こちらのページ](https://mcts.ai/about/index.html)にMCTSの概要が掲載されていますので、ここでは基本的な考え方だけ説明します。

![MCTSの図解](mcts.png)

MCTSは、以下の4つのステップを繰り返して行われます：
1. **選択:** ルートから始めて、スコアを見ながら有望な葉ノードを探します。
2. **展開:** その葉ノードから1つの子ノードを生成します。
3. **シミュレーション:** 子ノードの仮サブツリーを構築してスコアリングします。
4. **逆伝播:** スコアを根ノードまで伝播します。

このプロセスを繰り返すことで、高スコアの状態を見つけることが期待されます。詳しくは次の節で説明します。


<hr/>

[^vo_1]: もちろん、2語以上の複合語も存在しますが、2語の複合語が一般的です。また、2語の複合語に限定することで、問題の枠組みを管理しやすくなります。
[^vo_2]: 例外は100語余りしかないトキポナ（Toki Pona）です。
[^vo_3]: 複合語に使われる基本語の数を最小化することと、複合語の数を最大化することには必然的なトレードオフがあります。というのも、*I*（基本的なアイデアの集合）が有限であるため、*I*から複合語として表現するアイデアを増やすほど、複合語を作るために選べる基本語の数が減るからです。